<!DOCTYPE html>
<html lang="en">
<head>
	<title>{{ title }}</title>
	<meta charset="UTF-8">
<!--	<link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/source-sans-pro" type="text/css"/>-->
	<link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/cabin" type="text/css"/>

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
   integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
   crossorigin=""/>

	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
   integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
   crossorigin=""></script>

	<script type='text/javascript' src='https://cdn.jsdelivr.net/gh/rizac/leaflet-poly-marker/polymarker.min.js'></script>

	<!-- Layout related style (necessary): -->
	<style type="text/css">
		body{
			padding: 0px;
			margin: 0px;
			width:100vw;
			height:100vh;
		}
		body > div, h3{
			margin-left: 0.5rem;
			margin-right: 0.5rem;
		}
		#map {
			flex: 1 0 auto;
			margin-bottom:.5rem;
		}
		.main-div{
			overflow:hidden;
			flex: 1 0 auto;
		}
		.side-div{
			flex: 1 0 auto;
			width: 100%;
			max-width: 100%;
		}
		.table-div{
			overflow:auto;
			max-width: 100%;
		}
		table thead td, table thead th{  /* Make sticky header: https://stackoverflow.com/a/47923622 */
			position: sticky; top: 0; z-index: 1;
			background-color: white; /* make tbody rows behind theader row, otherwise they overlap */
		}
		table{
			display:block;
			border-collapse: collapse;
		}
		table td button {
			width: 100%;
		}
		tr.selected{} /* this class is overwritten below only if we have more than one event to highlight the selected one */
		.header{
			position: relative;
			text-align: center;
		}
		#legend-btn{
			position: absolute;
			right: 0;
			bottom:0;
		}
		.desc{
			text-align:justify;
			position:fixed;
			padding:1rem;
			top: 5rem;
			right:.5rem;
			line-height:2rem;
			max-width:33vw;
			max-height: 50vh;
			overflow: auto;
			z-index: 1000;
		}
	</style>
	<!-- appearance style (important, not necessary): -->
	<style>
		body{
			font-family: Ubuntu, CabinRegular, sans-serif !important;
			font-size: 16px;
			background-color: #EEE !important;
		}
		.leaflet-container {  /* leaflet should use my font */
			font: inherit;
		}
		#map{
			border: 1px solid #CCC;
			margin-top:1rem;
		}
		button.btn:focus {
			outline: none;
			box-shadow: none;
			box-shadow: none !important;
		}
	</style>

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">

</head>
<body class="d-flex flex-row">
<div class="header" class="d-flex flex-column">
	<div>Event: <select>
		{%- for evt_id, evt_catalog_id in events_select.items() -%}
			<option onclick="showEvent({{ evt_id }})">{{ evt_catalog_id }}</option>
		{%- endfor -%}
	</select>
	</div>
	<div>
		{%- for evt_id, evt_table_content in events_table.items() -%}
			<table id='table-{{ evt_id }}' class='event-table'>
				{{ evt_table_content | safe }}
			</table>
		{%- endfor -%}
	</div>
</div>
<div class="main-div d-flex flex-column align-items-center">
	<div class="side-div d-flex flex-column">
		<div id="map"></div>
	</div>
</div>


<script type="text/javascript">

// Map related stuff:
// each element has: [event_lat, event_lon, event_mag, [[sta_lat, sta_lon, sta_code, sta_me, sta_dist_deg], ...]]:
var event_stations = {{ event_stations | tojson }};

var residualsFullScale = [-1, 1];  // REQUIREMENTS: first element <0, second element >0

// function converting an Me residual into a color in HTML string
function getColor(residual){
	if (residual == 0){
		return 'rgb(255, 255, 255)';
	}else if(residual > 0){  // red scale
		var maxRes = residualsFullScale[1];
		var value = Math.min(residual, maxRes) / maxRes;
		value = Math.round(255*value);
		return `rgb(255, ${255 - value}, ${255 - value})`;
	}else{  // blue scale
		var minRes = residualsFullScale[0];
		var value = Math.max(residual, minRes) / minRes;
		value = Math.round(255*value);
		return `rgb(${255 - value}, ${255 - value}, 255)`;
	}
}


// create the Leaflet map:
var map = L.map('map', {
	// worldCopyJump: true,
	zoom: 5,
	//minZoom:9,
	center: new L.latLng([50, 12]),
	layers: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
	layers: [
		L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
			subdomains: 'abcd',
			maxZoom: 19
		})
	]
});


// Create map legend (with color scale):
var legend = L.control({position: 'topright'});
legend.onAdd = function (map) {
	var div = L.DomUtil.create('div', 'info legend');
	div.innerHTML = "<span style='color:seagreen'>&#9711;</span> Event<br>" +
		"&#9651; Station(s) (click on symbol for details)<br>" + ` Station color: &Delta;Me = Me_station - Me_mean:<br>${residualsFullScale[0]} `;
	// display the colorbar as a series of spans, first negative scale then positive scale
	var colorScaleSteps = 4;  // number of spans will be 2 times this (negative+positive) plus the color for 0
	for (var i=0; i< colorScaleSteps; i++){
		var val = residualsFullScale[0] + i*Math.abs(residualsFullScale[0])/colorScaleSteps;
		div.innerHTML += `<span style="display:inline-block;height:.5rem;width:.5rem;border-bottom: 1px solid black;background-color:${getColor(val)}"></span>`;
	}
	div.innerHTML += `<span style="display:inline-block;height:.5rem;width:.5rem;border-bottom: 1px solid black;background-color:${getColor(0)}"></span>`;
	for (var i=0; i< colorScaleSteps; i++){
		var val = (i+1)*Math.abs(residualsFullScale[1])/colorScaleSteps;
		div.innerHTML += `<span style="display:inline-block;height:.5rem;width:.5rem;border-bottom: 1px solid black;background-color:${getColor(val)}"></span>`;
	}
	div.innerHTML += ` ${residualsFullScale[1]}`;
	return div;
};
legend.addTo(map);


function showEvent(event_id){
	for (var elm of document.querySelectorAll('.event-table')){
		elm.style.display='none';
	}
	document.getElementById('table-'+event_id).style.display = '';
	showMap(event_id);
}

// function updating the map on event selection
function showMap(eventId){
	// get event info (quick and dirt, from table):
	var [evLat, evLon, stations] = event_stations[eventId];

	// clear map:
	map.eachLayer(function (layer) {
		if (layer instanceof L.FeatureGroup){
			map.removeLayer(layer);
		}
	});

	// Display stations around event. This is a problem for longitues only because in
	// leaflet is kind of continuous (To see it, zoom out and scroll horizontally). Basically
	// shift station longitues of 360deg if they are more than 180 deg distant from the event
	// (solution inspired from a similar problem here: // https://stackoverflow.com/a/38824652)
	var adjustLng = lng => evLon - lng > 180 ? lng + 360 : (evLon - lng < -180 ? lng - 360 : lng) ;

	// repopulate map with new event and stations.
	// First put everything into a 'markers' Array:
	var SIZE = 12;
	var stas = stations;
	var [minLng, maxLng] = [null, null];
	var markers = stas.map(function(element){
		var latLng = [element[0], adjustLng(element[1])];

		if ((minLng === null) || (minLng > latLng[1])){
			minLng = latLng[1];
		}
		if ((maxLng === null) || (maxLng < latLng[1])){
			maxLng = latLng[1];
		}

		var distDeg = element[4];
		var deltaMe = element[3];
		var options = {
			marker: '^',
			radius: SIZE,
			weight: 1,  // border width
			fillColor: getColor(deltaMe),
			fillOpacity: 1,
			color: '#666666',
			opacity: 1
		};
		if (typeof deltaMe === 'number'){  // might be null
			deltaMe = deltaMe.toFixed(3);
		}

		var popupContent = `<table><tr><td>Station</td><td><b>${element[2]}</b></td></tr><tr><td>&Delta; Me</td><td>${deltaMe}</td></tr><tr><td>Event distance</td><td>${distDeg}&deg;</td></tr></table>`;
		return L.polyMarker(latLng, options).bindPopup(popupContent);
	});

	// Add event (beach ball icon):
	var evtLatLng = L.latLng(evLat, evLon);
	markers.push(L.circleMarker(evtLatLng, {
		color: 'seagreen',
		opacity: 1,
		fillColor: 'white',
		fillOpacity: 1,
		weight: 1,  // border width
	}));

	// Add event ("normal" circle, uncomment for debugging purposes):
	// markers.push(L.circleMarker([evLat, evLon], {weight:1, color:'black', fillColor:'#555', fillOpacity: 1, radius: 7}));

	// Create featuresGroup and add all markers we created to it. This way, it is easier
	// to clear the map by removing the group only (see the snippet above where we clear the map)
	var featureGroup = L.featureGroup(markers, {noWrap: true}).addTo(map);

	// center to event (not needed, zoom below is sufficient):
	// map.panTo(new L.LatLng(evLat, evLon));

	// zoom to markers for a better display:
	map.fitBounds(featureGroup.getBounds());
}

showEvent({{ selected_event_id }});
</script>
</body>
</html>